例题：CityUOJ12
题意：求逆序对个数
解决方法：归并（先不考虑）、树状数组
原理：
对于每一个数，你都想统计这个数前面有几个数比他大

例如：a[n]={5 6 4 1 2 3}
对于a[0]、a[1]，前面没有比他大的
对于a[2]，前面比他大的有2个，ans+=2
对于a[3]、a[4]、a[5]，前面比他大的有3个，ans+=3*3
最终ans=11

但是如果对每一个数都要去扫前面，那时间肯定不够（n^2）

所以我们用树状数组szsz[n]来维护记录
介绍两个函数：
find(x=a[i])//对于每一个数a[i]，搜寻他前面出现的比他小的数
{
	int tot=0 ;
	while(x){
		tot+=szsz[x] ;
		x-=x&-x ; //!!!这步的意思是，e.g.：6->4->0，3->2->0，17->16->0
	}
	return tot ;
}
modify(x=a[i])//用完a[i]后，将他加入到树状数组中维护（向上传递）
{
	while(x<=n){
		szsz[x]++ ;
		x+=x&-x ;
	}
}
那么find就可以求得在该数前小于他的数，那么大于他的数就是i-find(a[i])，所以
solve(){
	int ans=0 ;
	for(int i=0;i<n;i++){
		ans+=i-find(a[i]) ;
		modify(a[i]) ;
	}
	return ans ;
}
就可以得出答案了