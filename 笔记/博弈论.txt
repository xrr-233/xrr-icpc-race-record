Nim游戏：
n堆石子，从其中一堆拿1个以上石子，最后拿完的人赢

朴素算法：
首先找规律：一堆先手必赢，两堆相等先手必输
推导：如果当前状态的子状态有一个必败态，那当前状态即必胜态
如果当前状态的所有子状态都为必胜态，那当前状态即必败态
因此，对一个状态可以递归（dp）+记忆化搜索，时间O（a1*a2*a3...an）->过慢

优化算法：当且仅当a1^a2^a3...an=0时为必败态
证明：
1.最终态{0}为必败态，a1=0 ；
2.对于某个局面(a1,a2,...,an)，若a1^a2^...^an!=0，一定存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0
解释：不妨设a1^a2^...^an=k，则一定存在某个ai，这个ai的二进制表示-在k的最高位上-是1（否则k的最高位那个1是怎么得到的）。这时ai^k<ai一定成立。则我们可以将ai改变成ai'=ai^k，此时a1^a2^...^ai'^...^an=a1^a2^...^an^k=0。
3.对于某个局面(a1,a2,...,an)，若a1^a2^...^an=0，一定不存在某个合法的移动，将ai改变成ai'后满足a1^a2^...^ai'^...^an=0
解释：异或运算满足消去率，由a1^a2^...^an=a1^a2^...^ai'^...^an消消消，可以得到ai=ai'。所以将ai改变成ai'不是一个合法的移动
综上，证毕，时间O(n) ->nb

如果Nim游戏中的规则稍微变动一下,每次最多只能取K个,怎么处理?
方法是将每堆石子数mod (k+1).

例题：洛谷P1247、POJ2975


SG函数：
mex（minimum excludant）：表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3 mex{2,3,5}=0
定义：SG(x) = mex(S),其中 S是 x 后继状态的SG函数值的集合
例如：
有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？
SG[0]=0，f[]={1,3,4},
x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1;
x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;
x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;
x=4 时，可以取走4- f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;
x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;
以此类推…
x 0 1 2 3 4 5 6 7 8…
SG[x] 0 1 0 1 2 3 2 0 1…
必胜态的SG不为0，必败态的SG为0
/*若一个态必胜（SG不为0），则存在一个后继态SG = 0
若一个态必败（SG为0），则不存在一个后继态SG = 0*/（之前nim有类似描述）
SG（Sprague-Grundy）定理：一个大游戏的SG函数等于各个子游戏SG函数的Nim和（异或和）

例题：POJ2960、https://ac.nowcoder.com/acm/contest/338/I、UVALive5059